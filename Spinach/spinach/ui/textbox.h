#ifndef TEXTBOX_H
#define TEXTBOX_H

#include <iostream>
#include <sstream>
#include <iomanip>
#include <functional>
#include <string>

#include "../spinach/core/spn_canvas.h"
#include "../spinach/core/spn_image.h"
#include "../spinach/common/spn_utils.h"
#include "ui_scheme.h"
#include "widget.h"

namespace spn::rmgui {
	class Textbox : public Widget
	{
	public:

		Textbox() {
			text = "";
			Subscribe(UiEventType::CharInput);
			Subscribe(UiEventType::ActionKeyDown);
			Subscribe(UiEventType::MouseDown);
		}

		/*void SetCallback(std::function<void(int id, std::string& str)> onTextChangedCallback = nullptr) {
			onTextChangedFn = onTextChangedCallback;
		}*/

		void SetSize(int width, int height) {
			w = width;
			h = height;
		}

		void SetPosition(int ax, int ay) {
			x = ax;
			y = ay;
		}

		bool OnMouseDown(MouseButton button, int x, int y) {
			if (button == MouseButton::Left) {
				return OnLmbDown(x, y);
			}
			return false;
		}

		bool OnLmbDown(int mx, int my) {
			if (IsPointInsideTextBox(mx, my)) {
				SetFocus(true);
				caretShowFrames = 16;
				caretHideFrames = 16;
				isHover = true;
			}
			else {
				SetFocus(false);
				isHover = false;
			}
			return false;
		}

		bool OnActionKeyDown(KeyCode kc) {
			switch (kc) {
			case KeyCode::Left:
				return OnLeftArrowKey();
			case KeyCode::Right:
				return OnRightArrowKey();
			case KeyCode::Backspace:
				return OnBackSpaceKey();
			}
			return false;
		}
		bool OnCharInput(char c) {
			if (!HasFocus()) {
				return  false;
			}
			//text += c;
			text.insert(caretPosition, 1, c);
			MoveCaretRight();
			return true;
		};


		bool OnBackSpaceKey() {
			if (!HasFocus()) {
				return  false;
			}
			/*	if (text.size() > 0) {
					text.pop_back();
				}*/
			if (caretPosition == 0) {
				return false;
			}
			text.erase(caretPosition - 1, 1);

			caretShowFrames = 16;
			caretHideFrames = 16;
			MoveCaretLeft();
			return true;
		}


		bool OnLeftArrowKey() {
			if (!HasFocus()) {
				return  false;
			}
			MoveCaretLeft();
			caretShowFrames = 16;
			caretHideFrames = 16;

			return true;
		}

		bool OnRightArrowKey() {
			if (!HasFocus()) {
				return  false;
			}
			MoveCaretRight();
			caretShowFrames = 16;
			caretHideFrames = 16;
			return true;
		}


		void SetText(std::string& txt) {
			text = txt;
			caretPosition = (int)text.size();
			textScrollNeeded = true;
		}

		std::string& GetText() {
			return text;
		}

		// This function is generated by ChatGPT AI agent
		//void EnsureCaretVisible2(spn::Canvas* canvas)
		//{
		//	float visibleWidth = w - 6;
		//	float width = 0;

		//	// caret left of view
		//	if (caretPosition < scrollOffset) {
		//		scrollOffset = caretPosition;
		//		return;
		//	}

		//	// caret right of view
		//	for (int i = scrollOffset; i < caretPosition; i++) {
		//		float cw, ch;
		//		canvas->GetCharDisplaySize(text[i], cw, ch);
		//		width += cw;
		//	}

		//	if (width > visibleWidth) {
		//		scrollOffset++;
		//		EnsureCaretVisible2(canvas);
		//	}
		//}

		//This function is an optimization of the AI generated function
		void EnsureCaretVisible(spn::Canvas* canvas)
		{
			float visibleWidth = w - 6;
			float width = 0;
			bool flag = true;
			do {
				visibleWidth = w - 6;
				width = 0;
				if (caretPosition < scrollOffset) {
					scrollOffset = caretPosition;
					break;
				}
				for (int i = scrollOffset; i < caretPosition; i++) {
					float cw, ch;
					canvas->GetCharDisplaySize(text[i], cw, ch);
					width += cw;
				}
				if (width > visibleWidth) {
					scrollOffset++;
					continue;
				}
				flag = false;
			} while (flag);
		}


		void Display(spn::Canvas* canvas) {
			if (textScrollNeeded) {
				EnsureCaretVisible(canvas);
				textScrollNeeded = false;
			}

			int cwidth = canvas->GetWidth();
			int cheight = canvas->GetHeight();
			canvas->SetClippingRectangle(x, y, w, h);
			canvas->SetPrimaryColorUint(
				UiScheme::GetInstance().textColor);

			canvas->DrawCStringInRange(text.c_str(), scrollOffset, text.size(), x + 4, y);

			if (HasFocus()) {
				if (--caretShowFrames > 0) {
					float tw = 0, th = 0;
					if (caretPosition > 0) {
						//canvas->GetStringDisplaySizeInRange(text, 0, caretPosition-1, tw, th);
						if (caretPosition > scrollOffset) {
							canvas->GetStringDisplaySizeInRange(
								text,
								scrollOffset,
								caretPosition - 1,
								tw,
								th
							);
						}

					}

					/*if (tw > w-4) {
						maxWidthTaken = true;
					}
					else {
						maxWidthTaken = false;
					}*/
					//canvas->DrawChar(caret, x + tw, y);
					canvas->SetPrimaryColor(255, 255, 0);
					canvas->DrawLine(x + 2 + tw, y + 2, x + 2 + tw, y + h - 2);
				}
				else if (--caretHideFrames < 0) {
					caretShowFrames = 30;
					caretHideFrames = 30;
				}
				canvas->SetPrimaryColorUint(
					UiScheme::GetInstance().buttonHoverColor);

			}
			else {
				canvas->SetPrimaryColorUint(
					UiScheme::GetInstance().buttonReleaseColor);
			}
			canvas->DrawRectangle(x, y, x + w, y + h);
			canvas->SetClippingRectangle(0, 0, cwidth, cheight);
		}
	private:
		bool IsPointInsideTextBox(int mx, int my) {
			return (mx >= x) &&
				(mx <= x + w) &&
				(my >= y) &&
				(my <= y + h);
		}

		void MoveCaretLeft() {
			if (caretPosition > 0) {
				--caretPosition;
				textScrollNeeded = true;
			}
			//std::cout << caretPosition << '\n';
		}

		void MoveCaretRight() {
			if (caretPosition < text.size()) {
				++caretPosition;
				textScrollNeeded = true;
			}
			//std::cout << caretPosition << '\n';
		}


		/*std::function<void(int, std::string&)> onTextChangedFn;*/
		float x = 0;
		float y = 0;
		float w = 0;
		float h = 0;
		bool isHover = false;
		char caret = '|';

		std::string text;
		int start = 0;
		int end = 0;
		bool maxWidthTaken = false;
		int caretPosition = 0;
		int caretShowFrames = 16;
		int caretHideFrames = 16;
		int scrollOffset = 0;
		bool textScrollNeeded = true;
	};

}

#endif 
