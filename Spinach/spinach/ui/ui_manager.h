#ifndef UI_MANAGER_H
#define UI_MANAGER_H
#include <memory>
#include <vector>
#include "../core/spn_canvas.h"
#include "ui_event.h"
#include "widget.h"

class UiManager {
public:
	inline static UiManager& GetInstance() {
		static UiManager instance;
		return instance;
	}

	void Display(spn::Canvas* canvas) {
		int i = 0;
		int focusIdx = -1;
		Widget* focused = nullptr;
		for (const auto& w : widgets) {
			if (w->HasFocus()) {
				focused = w.get();
			}
			else {
				w->Display(canvas);
			}
		}
		if (focused!=nullptr) {
			focused->Display(canvas);
		}

	}

	void Display2() {
		int i = 0;
		int focusIdx = -1;
		int count = 0;
		for (const auto& w : widgets) {
			if (w->HasFocus()) {
				focusIdx = i;
				++count;
			}
			++i;
		}
		//std::cout << count;
	}

	bool HandleUiEvent(UiEvent& uie) {
		if (uie.eventType == UiEventType::None) {
			return false;
		}

		for (auto it = widgets.rbegin(); it != widgets.rend(); ++it) {
			Widget* w = it->get();
			if (!w->IsSubscribed(uie.eventType)) {
				continue;
			}

			if (DispatchToWidget(*w, uie)) {
				return true;
			}
		}
		return false;
	}

	bool UiManager::DispatchToWidget(Widget& w, UiEvent& e) {
		switch (e.eventType) {
		case UiEventType::MouseDown:
			return w.OnMouseDown(e.mouseButton, e.mouseX, e.mouseY);

		case UiEventType::MouseUp:
			return w.OnMouseUp(e.mouseButton, e.mouseX, e.mouseY);

		case UiEventType::MouseMove:
			return w.OnMouseMove(e.mouseX, e.mouseY);

		case UiEventType::MouseDrag:
			return w.OnMouseDrag(e.mouseX, e.mouseY);

		case UiEventType::CharInput:
			return w.OnCharInput(e.character);
		case UiEventType::ActionKeyDown:
			return w.OnActionKeyDown(e.keyCode);
		case UiEventType::ActionKeyUp:
			return w.OnActionKeyUp(e.keyCode);
		}

		return false;
	}




	// This function is generated by ChatGPT AI agent
	/*template<typename T, typename... Args>
	T* CreateWidget(Args&&... args) {
		static_assert(std::is_base_of_v<Widget, T>, "T must derive from Widget");

		auto w = std::make_unique<T>(std::forward<Args>(args)...);
		T* ptr = w.get();
		widgets.emplace_back(std::move(w));
		return ptr;
	}*/

	//This function is an optimization of the AI generated function
	template<typename T>
	T* CreateWidget() {
		static_assert(std::is_base_of_v<Widget, T>, "T must derive from Widget");
		auto w = std::make_unique<T>();
		T* ptr = w.get();
		widgets.emplace_back(std::move(w));
		return ptr;
	}


private:
	std::vector<std::unique_ptr<Widget>> widgets;
	UiManager() = default;
	UiManager(const UiManager&) = delete;
	UiManager& operator=(const UiManager&) = delete;
};

#endif